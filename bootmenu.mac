; --------------------------------------------------
; A simple boot menu meant for a PDP-11/23
; The goal is to be able to boot DU, DD
; and MU devices easily.
;
; 2025 - Peter Ekstrom
; --------------------------------------------------
;	.enabl	AMA
	.asect
romstr	= 14000
;
conrxs  = 177560 		; Term in stat
conrxb  = conrxs+2		; Term in buff
contxs  = conrxb+2		; Term out stat
contxb  = contxs+2		; Term out buff
ltcreg	= 177546		; Line Time Clock register, bit 6
ltcvt	= 100			; Line Time Clock vector
ltcpsw	= 102			; Line Time Clock PSW
pcrreg	= 177520		; BDV-11 Page Control register
rwreg	= 177522		; BDV-11 Read/Write register
swtreg	= 177524		; BDV-11 switch/LED register
				; E15 1-8 = bits 0-7
				; E21 1-4 = bits 8-11
				; Switch on = 1, off = 0
				; LEDs 1-4 = bits 0-3
				; LED off=1, on=0
e151	= 000001		; E15, switch 1 bit
e152	= 000002		; E15, switch 2 bit
e153	= 000004		; E15, switch 3 bit
e154	= 000010		; E15, switch 4 bit
e155	= 000020		; E15, switch 5 bit
e156	= 000040		; E15, switch 6 bit
e157	= 000100		; E15, switch 7 bit
e158	= 000200		; E15, switch 8 bit
e211	= 000400		; E21, switch 1 bit
e212	= 001000		; E21, switch 2 bit
e213	= 002000		; E21, switch 3 bit
e214	= 004000		; E21, switch 4 bit
	.radix	2
swtbts	= 1111000000000000
ltcbts	= 0000000001000000
	.radix	8
; --------------------------------------------------
; RAM locations variables
; --------------------------------------------------
seldev	=1000			; Selected device
selunt	=1002			; Selected unit #
crc16	=1004			; Checksum storage
rpkt	=1006
cpkt	=1072
comm	=2406
;
; --------------------------------------------------
; Main Program
; --------------------------------------------------
;
	.=romstr		; Load address
;
; Main entry point
;
init:	mov	#1000,sp	; Setup stack
	tst	-(sp)
	mov     #000340,177776  ; Raise interrupt pri
        reset                   ; Reset the bus
;
	mov	#clrscn,r1
	jsr	pc,prtstr
;
; Clear and initialize trap vectors
;
	mov	#0,r4
clrtrp:	clr	(r4)+
	cmp	r4,#300
	bne	clrtrp
	jsr	pc,cpytrp	; Initialize traps
;
	jsr	pc,inimem	; Initialize memory
	jsr	pc,inibdv	; Initialize BDV-11
;
start:	mov	#clrscn,r1
	jsr	pc,prtstr
	jsr	pc,iniltc	; Initialize LTC
;
;	bit	#4000,@#swtreg	; Auto-boot ?
;	beq	domenu
;
domenu:	mov	#17.,r1		; Print 17 spaces
	jsr	pc,prtspc
	mov	#banner,r1	; Point to banner
	jsr	pc,prtstr
	mov	#25.,r1		; Print 25 spaces
	jsr	pc,prtspc
	mov	#verstr,r1	; Point to version
	jsr	pc,prtstr
;
	mov	#33.,r1		; Print 33 spaces
	jsr	pc,prtspc
	mov	#bywho,r1	; Point to author
	jsr	pc,prtstr
;
	mov	#btmnu,r1	; Point to menu
	jsr	pc,prtstr
	mov	#ctzmsg,r1	; Point to ctrlz msg
	jsr	pc,prtstr
;
; Get boot device selection
;
devagn:	clr	@#seldev
	mov	#btsdev,r1	; Prompt for device
	jsr	pc,prtstr
	jsr	pc,getchr	; Get device choice
	jsr	pc,prtchr	; Echo selection
	cmpb	#32,r0		; Check for CTRL-Z
	beq	start
	cmpb	#30,r0		; Check for CTRL-X
	bne	devag2
	halt
devag2:	cmpb	#61,r0		; Device 1 (DU)?
	beq	getunt
	cmpb	#62,r0		; Device 2 (DD)?
	beq	getunt
	cmpb	#63,r0		; Device 3 (MU)?
	beq	getunt
	cmpb	#64,r0		; Device 4 (XE)?
	beq	getunt
;
devunk:	jsr	pc,unkprt	; Unknown msg
	br	devagn		; Loop back
;
; Get boot unit selection
;
getunt: movb	r0,seldev	; Store selected device
untagn:	clr	@#selunt
	mov	#btunit,r1	; Prompt for unit #
	jsr	pc,prtstr
	jsr	pc,getchr	; Get unit number
	jsr	pc,prtchr	; Echo selection
	cmpb	#32,r0		; Check for Ctrl+Z
	beq	start
	cmpb	#30,r0		; Check for CTRL-X
	bne	untag2
	halt
untag2:	cmpb  	r0,#60		; Check unit is 0-9
	blt	untunk
	cmpb 	r0,#71
	bgt	untunk
	br	doboot
;
untunk:	jsr	pc,unkprt	; Unknown unit #
	br	untagn
;
doboot:	sub	#60,r0		; Convert from ASCII
	movb	r0,selunt	; Store selected unit
	jmp	bootdv		; Boot selected dev/unit
; --------------------------------------------------
; Unknown selection message
; --------------------------------------------------
unkprt:	mov	#btunk,r1
	jsr	pc,prtstr
	rts	pc
; --------------------------------------------------
; Print r1 spaces
;
; r1 - space count
; --------------------------------------------------
prtspc:	movb	#32.,r0
prtsp2:	jsr	pc,prtchr
	sub	#1,r1
	beq	prtsp3
	br	prtsp2
prtsp3:	rts	pc
; --------------------------------------------------
; Print string to console
;
; r1 - string pointer
; --------------------------------------------------
prtstr:	movb	(r1)+,r0
	cmp	r0,#0
	beq	prtend
	jsr	pc,prtchr	; Print char
	br	prtstr
prtend:	rts	pc
; --------------------------------------------------
; Print char to console
;
; r0 - char to print
; --------------------------------------------------
prtchr:	movb	r0,@#contxb
prtwt2:	tstb	@#contxs
	bpl	prtwt2
	rts	pc
; --------------------------------------------------
; Get a char from console
;
; r0 - input character
; --------------------------------------------------
getchr:	tstb	@#conrxs
	bpl	getchr
	movb	@#conrxb,r0
	rts	pc
; --------------------------------------------------
; Init trap locations
; --------------------------------------------------
trpstr: .word   2               ; Reserved vector
        .word   0
        .word   4               ; Time-out/system error vector
        .word   0               ; Bus error trap
        .word   10              ; Illegal and reserved instruction vector
        .word   0               ; Reserved instruction trap
        .word   14              ; BPT instruction vector
        .word   0
        .word   20              ; IOT instruction vector
        .word   0
        .word   24              ; Power fail vector
        .word   0
        .word   30              ; EMT instruction vector
        .word   0
        .word   34              ; TRAP instruction vector
        .word   0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
        .word   114		; Memory parity
        .word   0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
	.word	0
        .word   240		; PIRQ, Prog int req
        .word   0
        .word   244		; Floating point
        .word   0
        .word   250		; Memory management
        .word   0
trpend  = .

cpytrp: mov     #trpstr,r4
        mov     #0,r5
cpylp:  mov     (r4)+,(r5)+
        cmp     #trpend,r4
        bne     cpylp
        rts     pc
; --------------------------------------------------
; Initialize the LTC
iniltc:	mtps	#340		; Set PSW to priority 7
	reset
	mov	@#4,r3		; Save the vector
	mov	#1$,@#4		; Setup our vector
	tst	@#ltcreg
	br	4$
;
1$:	br	2$
;
4$:	mov	@#lctvec,r3	; Save the vector
	mov	#5$,@#lctvec	; Setup our vector
	bit	#300,@#lctreg	; Test for LCT enabled bit
	mov	#clkena,r1	; LTC enabled
	jsr	pc,prtstr
	mov	r3,@#lctvec	; Restore the vector
	br	3$
;
5$:	mov	r3,@#lctvec	; Restore the vector
	br	3$
;
2$:	mov	r3,@#4		; Restore saved vector
	mov	#clkdis,r1	; LTC disabled
	jsr	pc,prtstr
	br	3$
;
3$:	rts	pc
; --------------------------------------------------
; Initialize the BDV-11 board
; --------------------------------------------------
inibdv:	mov     @#2,r2		; Save vectors
	mov	@#4,r3
	mov     @#10,r4
	mov     #1$,@#2		; Set our vector
	mov     #1$,@#4
	mov     #1$,@#10
	mov     #400,@#pcrreg	; Set PCR to page 0
	tst     @#swtreg	; Test access to switch register
	clr     @#swtreg	; Turn on all LEDs
	mov	#2.,r0		; Wait 2ms
	mov     #17,@#swtreg	; Turn off all LEDs
	mov	#2.,r0		; Wait 2ms
1$:	mov     r2,@#2		; Restore vectors
	mov	r3,@#3
	mov     r4,@#10
	rts	pc
; --------------------------------------------------
; Initialize memory
; --------------------------------------------------
inimem:	mov	#tstmem,r1	; Testing memory
	jsr	pc,prtstr
	mov	@#10,r3		; Save vector
	mov	@#20,r4		; Save vector
	mov	@#24,r5		; Save vector
	mov	#2$,@#10	; Setup our vector
	mov	#2$,@#20	; Setup our vector
	mov	#2$,@#24	; Setup our vector
	clr	r0		; Point to zero
1$:	tst	(r0)+		; Increment pointer
	beq	2$		; See if we are done
	br	1$		; No, loop again
2$:	mov	r5,@#24		; Restore vector
	mov	r4,@#20		; Restore vector
	mov	r3,@#10		; Restore vector
	rts	pc
; --------------------------------------------------
; Invalid unit number
; --------------------------------------------------
prtinv:	mov	#untinv,r1
	jsr	pc,prtstr
	jmp	untagn
; --------------------------------------------------
; Boot selected device
; --------------------------------------------------
bootdv:	cmp	#61,@#seldev	; DU device
	bne	bootd1
	cmp	@#selunt,#8.
	bhi	prtinv
	jmp	bootdu
bootd1:	cmp	#62,@#seldev	; DD device
	bne	bootd2
	cmp	@#selunt,#1.
	bhi	prtinv
	jmp	bootdd
bootd2:	cmp	#63,@#seldev	; MU device
	bne	bootd3
	cmp	@#selunt,#3.
	bhi	prtinv
	jmp	bootmu
bootd3:	cmp	#64,@#seldev	; XE device
	bne	noboot
	cmp	@#selunt,#1.
	bhi	prtinv
	jmp	bootxe
;
noboot:	jmp	start
; --------------------------------------------------
; Print unit number
; --------------------------------------------------
prtunt:	mov	@#selunt,r0
	add	#60,r0
	jsr	pc,prtchr
	mov	#crlf,r1
	jsr	pc,prtstr
	rts	pc
; --------------------------------------------------
; Boot error handler
; --------------------------------------------------
btehdl:	mov	#bterr,r1
	jsr	pc,prtstr
	jmp	devagn
; --------------------------------------------------
; DU boot loader for RD-type disks
; --------------------------------------------------
bootdu:	mov	#dubmsg,r1
	jsr	pc,prtstr
	jsr	pc,prtunt
	mov	@#selunt,r0	; Unit number in r0
	br	duNr		; Jump to boot code
;
ducsr	=172150		; Std MSCP csrbase
duip	=+0		; IP register
dusa	=+2		; SA register
;
; MSCP init data
;
inidta:	.word  100000	; S1: 100000 = no int, ring size 1, no vector
	.word  002406	; S2: 002404 = ringbase lo addr
	.word  000000	; S3: 000000 = no purge/poll, ringbase hi addr
	.word  000001	; S4: 000001 = go bit
;
; MSCP command data
;
	.byte  011,000	; cmd=011(online) bytecnt_hi=000(0.)
	.byte  041,002	; cmd=041(read)   bytecnt_hi=002(512.)
;
du0n:	sec		; boot std csr, unit zero, no diags
du0d:	mov    #0,r0	; boot std csr, unit zero, with diags
duNr:	mov    #ducsr,r1; boot std csr, unit <r0>
duNb:	mov    pc,r4	; boot csr <r1>, unit <r0>
;
dustrt:	mov    r0,(r1)+	; init controller (write IP), bump ptr
	mov    #4000,r5	; S1 state bitmask
	mov    #inidta,r3	; point to data at next word
;
; init loop
;
3$:	tst    (r1)	; error bit set ?
	bmi    7$	; yes, fail back to begin to retry
	bit    (r1),r5	; step bit set ?
	beq    3$	; not yet, wait loop
	mov    (r3)+,(r1) ; yes, send next init data
	asl    r5	; next mask
	bpl    3$	; S4 done? br if not yet
;
; Command loop
;
4$:	clr    r2	; set bufptr to 0
5$:	clr    (r2)+	; clear buffer [0..comm-1]
	cmp    r2,#comm	; check for end of buffer
	bne    5$
;
; r0 = unit #
; r1 = a(sa)
; r2 = a(comm)
; r3 = a(table)
; r4 = <unused>
; r5 = 100000
; sp = <unused>
;
	mov    r2,@#cpkt-4. ; set cmd packet length
	movb   (r3)+,@#cpkt+8. ; set cmd opcode
	movb   (r3),@#cpkt+13. ; set cmd bytecnt hi
	mov    r0,@#cpkt+4.    ; set cmd unit
;
	mov    #rpkt,(r2)+     ; rq desc addr
	mov    r5,(r2)+        ; rq own bit15
	mov    #cpkt,(r2)+     ; cp desc addr
	mov    r5,(r2)+        ; rq own bit15
;
	mov    -2(r1),r2       ; wake controller (read IP)
;
; Wait loop
;
6$:	tst    @#comm+2.       ; req own controller ?
	bmi    6$              ; loop if not done

	tstb   @#rpkt+10.      ; check for error ?
	bne    7$		; Yes, fail back to begin to retry

	tstb   (r3)+           ; check end of table ?
	beq    4$              ; jmp to bootstrap at zero
;
	clr    -(r1)           ; init controller (write IP)
        clr    pc              ; jump to boootstrap at 0
;
	halt
	.word  0
;	jmp	start
7$:	jmp	btehdl
; --------------------------------------------------
; DD boot loader for TU58 DECtape II
; --------------------------------------------------
bootdd:	mov	#ddbmsg,r1
	jsr	pc,prtstr
	jsr	pc,prtunt
	mov	@#selunt,r0
	br	ddNr
;
ddcsr	=176500				; std TU58 csrbase
ddrcsr	=+0				; receive control
ddrbuf	=+2				; receive data
ddxcsr	=+4				; transmit control
ddxbuf	=+6				; transmit data
;
dd0n:	sec				; boot std csr, unit zero, no diags
dd0d:	mov	#0,r0			; boot std csr, unit zero, with diags
ddNr:	mov	#ddcsr,r1		; boot std csr, unit <R0>
ddNb:	mov	pc,r4			; boot csr <R1>, unit <R0>
	br	ddinit			; return to (R4)+2 from diags
;
ddinit:	clr	r4			; zap old return address
	inc	ddxcsr(r1)		; set break bit
	clr	r3			; data 000,000
	jsr	pc,d10$			; transmit a bunch of zero chars
	clr	ddxcsr(r1)		; clear break bit
	tst	ddrbuf(r1)		; read/flush any stale rx char
	mov	#<010*400>+004,r3	; data 010,004
	jsr	pc,d12$			; transmit 004 (init) and 010 (boot)
	mov	r0,r3			; get unit number
	jsr	pc,d13$			; transmit unit number
;
	clr	r3			; clear rx buffer ptr
d2$:	tstb	(r1)			; wait for rcv'd char available
	bpl	d2$			; br if not yet
	movb	ddrbuf(r1),(r3)+	; store the char in buffer, bump ptr
	cmp	#1000,r3		; hit end of buffer (512. bytes)?
	bhi	d2$			; br if not yet
;
	clr	pc			; jump to bootstrap at zero
;
d10$:	jsr	pc,(pc)			; recursive call for char replication
d11$:	jsr	pc,(pc)			; recursive call for char replication
d12$:	jsr	pc,(pc)			; recursive call for char replication
d13$:	tstb	ddxcsr(r1)		; wait for xmit buffer available
	bpl	d13$			; br if not yet
	movb	r3,ddxbuf(r1)		; send the char
	swab	r3			; swap to other char
	rts	pc			; now recurse or return
;
	halt
; --------------------------------------------------
; MU boot loader for TK50 tapes
;
; I had to keep some seemingly unnecessary stuff in
; the code because the routine relies on the values
; of the instruction words for various conditions.
; One of these days I'm going to sit down and figure
; out how to modify the conditions so I can remove
; unnecessary stuff.
; --------------------------------------------------
bootmu:	mov	#mubmsg,r1
	jsr	pc,prtstr
	jsr	pc,prtunt
	mov	@#selunt,r0
	br	muNr
;
mucsr	=174500				; std TMSCP csrbase
muip	=+0				; IP register
musa	=+2				; SA register
diags   =165564                         ; console diags phase2 entry
;
	.ascii	"UM"
	.word	mulast-.
mu0n:	sec				; boot std csr, unit zero, no diags
mu0d:	mov	#0,r0			; boot std csr, unit zero, with diags
muNr:	mov	#mucsr,r1		; boot std csr, unit <R0>
muNb:	mov	pc,r4			; boot csr <R1>, unit <R0>
	nop
	br	minit			; return to (R4)+2 from diags
					; then skip over pseudo reboot vector
;
	jmp	@#diags
mrpkt	=100000	; rpkt structure
mcpkt	=100100 ; cpkt structure
mcomm	=100200	; comm structure
; command byte.cnt.hi/opc.hi table
iniend	=.	
	.byte	002,041			; #3 bch(002), opc(041)=read
	.byte	076,041			; #2 bch(076), opc(041)=read
	.byte	000,011			; #1 bch(000), opc(011)=online
; init sequence table
	.word	000001			; S4: go bit
	.word	000000			; S3: no purge/poll, ringbase hi addr
	.word	mcomm			; S2: ringbase lo addr
	.word	100000			; S1: no intr, ring size 1, no vector
;
minit:	mov	pc,r3			; point to next word
	mov	r1,r2			; a(IP) in R1
	mov	-(r3),(r2)+		; decr data ptr, a(SA) in R2
	mov	#4000,r5		; S1 state bitmask
; init loop
m3$:	tst	(r2)			; error bit set ?
	bmi	m7$			; yes, fall back to begin to retry
	bit	(r2),r5			; step bit set ?
	beq	m3$			; not yet, wait loop
	mov	-(r3),(r2)		; yes, send next init data
	asl	r5			; next mask
	bpl	m3$			; s4 done? br if not yet
; command loop
m4$:	mov	r5,r2			; set bufptr to rpkt=100000
m5$:	clr	(r2)+			; clear buffer [0..comm-1]
	tstb	r2			; check for end of buffer
	bpl	m5$			; loop if not done
;
	incb	@#mcpkt-1.		; set cmd len = 400
	incb	@#mcpkt-3.		; set cmd VCID = 1
	movb	-(r3),@#mcpkt+8.		; set cmd opcode from table
	movb	-(r3),@#mcpkt+13.	; set cmd bytecnt hi from table
	mov	r0,@#mcpkt+4.		; set cmd unit
;	
	mov	r5,(r2)+		; rq desc addr = rpkt
	mov	r5,(r2)+		; rq own bit15
	mov	#mcpkt,(r2)+		; cp desc addr = cpkt
	mov	r5,(r2)			; cp own bit15
;
	tst	(r1)			; wake controller (read IP)
	cmp	-(r2),-(r2)		; r2 -= 4
; wait loop
m6$:
	tstb	@#mrpkt+10.		; check for error ?
	bne	m7$			; yup, fall back to begin to retry
;
	tst	(r2)			; rq own controller ?
	bmi	m6$			; loop if not done
;
	cmp	#iniend,r3		; check if end of table ?
	blo	m4$			; branch if not yet
;
	clr	pc			; jmp to bootstrap at zero
;
;crc16:	.word	<011426>
mulast:
;
	halt
m7$:	jmp	btehdl
; --------------------------------------------------
; XE boot loader for DEQNA network
; --------------------------------------------------
bootxe:	mov	#xebmsg,r1
	jsr	pc,prtstr
	jsr	pc,prtunt
	mov	@#selunt,r0
	br	xeNr
;
; ROM #1
;
;devbas	=174510				; device csr base address
devbas	=174440				; device csr base address

;diags	=165564				; console diags phase2 entry
	
;	.asect
;	.=173000

	; --------------------------------------------------

;start:	.ascii	"EX"			; device code (reversed)

;	.word	last-.			; offset to next boot header

xestart:
xe0n:	sec				; boot std csr, unit zero, no diags
xe0d:	mov	#0,r0			; boot std csr, unit zero, with diags
xeNr:	mov	#devbas,r1		; boot std csr, unit <R0>
xeNb:	mov	pc,r4			; boot csr <R1>, unit <R0>
;	bcc	diag			; br if diags requested
	br	go			; return to (R4)+2 from diags
					; then skip over the pseudo reboot vector
	
	; --------------------------------------------------

;	.word	173000			; prom start addess @ 24
;	.word	340			; and priority level @ 26

	; --------------------------------------------------

dat:	.word	004001			; CLR.DONE + CMD=GET_PCBB
	.word	004002			; CLR.DONE + CMD=GET_CMD
	.word	000000			; CMD=NOP and end of table

	; --------------------------------------------------

go:	mov	pc,r2			; setup r2 ptr to data table
	sub	#.-dat,r2		; 
	mov	#4040,(r1)		; CLR.DONE + CMD=START

3$:	bit	#4000,(r1)		; test DONE set
	beq	3$			; loop until done sets

	mov	#700,r5			; ptr to PCBB control block
	mov	r5,4(r1)		; into devbas+4
	clr	6(r1)			; clear devbas+6
	mov	#2,(r5)+		; 

4$:	mov	(r2)+,(r1)		; get next command from table
	beq	6$			; 
	
5$:	bit	#4000,(r1)		; test DONE set
	beq	5$			; loop until set

	br	4$			; lopp for next command
	
6$:	mov	pc,r3			; point to inline ascii string
	br	8$			;

7$:	.ascii	<015><012>"ETHERNET PHYSICAL ADDRESS = "

8$:	tst	(r3)+			; point to ascii string start
	mov	#<8$-7$>,r4		; contains this many characters
	br	rom2			; br into next PROM

	; --------------------------------------------------

;diag:	jmp	@#diags			; jump to console diags

	; --------------------------------------------------

;	.word	0,0,0			; unused
;
; ROM #2
;
prtsts	=177564				; tty console printer status register
prtdat	=177566				; tty console printer data register

;	.asect
;	.=173000
	
	; --------------------------------------------------
	
;start:	.word	<-2>			; signal this is a continuation ROM

	; --------------------------------------------------
	
rom2:	movb	(r3)+,@#prtdat		; print character from buffer

1$:	tstb	@#prtsts		; wait until done printing
	bpl	1$			; 

	dec	r4			; decrement buffer count
	bne	rom2			; loop if more to print
	br	4$			; done printing

2$:	movb	#<'->,@#prtdat		; print a dash

3$:	tstb	@#prtsts		; wait until done printing
	bpl	3$			; 
	
4$:	movb	(r5)+,r3		; get next byte, extend to word
	bic	#^c377,r3		; clear upper half
	mov	r3,r0			; save a copy
	bicb	#360,r3			; clear upper nibble of byte
	ash	#-4,r0			; shift right four bits

	cmpb	#9.,r0			; compare digit 9.
	bge	5$			; br if 9. or more
	add	#<'7>,r0		; offset by ascii '7'
	br	6$			; continue
5$:	add	#<'0>,r0		; offset by ascii '0'
6$:	movb	r0,@#prtdat		; print character

7$:	tstb	@#prtsts		; wait until done printing
	bpl	7$			;

	cmpb	#9.,r3			; compare digit 9.
	bge	8$			; br if 9. or more
	add	#<'7>,r3		; offset by ascii '7'
	br	9$			; continue
8$:	add	#<'0>,r3		; offset by ascii '0'
9$:	movb	r3,@#prtdat		; print character

10$:	tstb	@#prtsts		; wait until done printing
	bpl	10$			;

	cmp	#710,r5			; hit end of data structure?
	bne	2$			; loop if not yet

	mov	#4005,(r1)		; CLR.DONE + CMD=BOOT into device register
	mov	#2,r0			; address [2] into r0
	mov	(pc)+,(r0)+		; next word into memory [2]; bump ptr
	 br	.			; ..this instruction word
	mov	r1,(r0)			; device register address into memory [4]
	jmp	-(r0)			; jump to location [2] 

	; --------------------------------------------------
	
;	.word	0,0,0			; unused

;	jmp 	start
; --------------------------------------------------
;
; String constants
;
; --------------------------------------------------
clrscn:	.ascii  <33>/[2J/<33>/[H/
	.byte	0
crlf:	.byte	12,15,0
banner:	.ascii	'PDP-11/23 BOOT MENU'
	.byte	0
verstr:	.ascii	'v0.90'
	.byte	12,15,0
bywho:	.ascii	'2025-P. Ekstrom'
	.byte	12,0
btmnu:  .byte   15,12,12
	.ascii	'  Select boot device:'
	.byte	12,12,15
        .ascii  '  1.  DU Device (units 0-8).'
	.byte   12,15
	.ascii	'  2.  DD Device (units 0-1).'
	.byte   12,15
	.ascii  '  3.  MU Device (units 0-3).'
	.byte   12,15
	.ascii  '  4.  XQ Device (units 0-1).'
	.byte   12,12,15,0
ctzmsg:	.ascii	'  Press CTRL-Z to restart menu.'
	.byte	12,15
	.ascii	'  Press CTRL-X to exit to ODT.'
	.byte	12,15,0
btsdev:	.byte	12,15
	.ascii	'  Select: '
	.byte	0
btunit:	.byte	12,15
	.ascii	'  Unit #: '
	.byte	0
btunk:	.byte	12,15
	.ascii	'Unknown selection.'
	.byte	0
untinv:	.byte	12,15
	.ascii	'Invalid unit selected.'
	.byte	0
bterr:	.byte	12,15
	.ascii	'  Boot error.'
	.byte	12,15,0
dubmsg:	.byte	12,12,15
	.ascii	'  Booting from DU'
	.byte	0
ddbmsg:	.byte	12,12,15
	.ascii	'  Booting from DD'
	.byte	0
mubmsg:	.byte	12,12,15
	.ascii	'  Booting from MU'
	.byte	0
xebmsg:	.byte	12,12,15
	.ascii	'  Booting from XQ'
	.byte	0
	.even
tstmem:	.ascii  <33>/[2J/<33>/[H/
	.ascii	'TESTING MEMORY'
	.byte	0,0
clkena:	.ascii	'CLOCK ENABLED '
	.byte	0,0
clkdis:	.ascii	'CLOCK DISABLED'
	.byte	0,0
	
;
	.end
